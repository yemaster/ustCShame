<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ustCShame</title> <!-- ä¿®æ”¹ï¼šç½‘é¡µæ ‡é¢˜ -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css/github-markdown.min.css">
  <style>
    :root {
      --primary-color: #0366d6;
      --hover-bg: #f6f8fa;
      --border-color: #e1e4e8;
      --text-secondary: #586069;
      --bg-color: #f6f8fa;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
      background-color: var(--bg-color);
      color: #24292e;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }

    /* === æ–°å¢ï¼šé¡µé¢å¤´éƒ¨ === */
    .page-header {
      margin-top: 40px;
      margin-bottom: 20px;
      text-align: center;
    }
    .page-title {
      font-size: 32px;
      font-weight: 300;
      color: #24292e;
      margin: 0;
    }

    .container {
      width: 90%;
      max-width: 980px;
      background: white;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
      display: flex;
      flex-direction: column;
      min-height: 500px;
      margin-bottom: 20px;
    }

    /* === é¡¶éƒ¨å·¥å…·æ  === */
    .header {
      padding: 12px 16px;
      background: #fcfcfc;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 15px;
    }

    .breadcrumb-container {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-secondary);
      flex: 1;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }
    .breadcrumb-item { cursor: pointer; color: var(--primary-color); }
    .breadcrumb-item:hover { text-decoration: underline; }
    .breadcrumb-separator { margin: 0 5px; color: #999; }

    .search-wrapper { position: relative; width: 250px; }
    .search-input {
      width: 100%; padding: 6px 12px; border: 1px solid var(--border-color);
      border-radius: 6px; font-size: 14px; outline: none; box-sizing: border-box;
    }
    .search-input:focus { border-color: var(--primary-color); box-shadow: 0 0 0 3px rgba(3, 102, 214, 0.3); }

    /* === åˆ—è¡¨å†…å®¹ === */
    .file-list { list-style: none; margin: 0; padding: 0; }
    .file-item {
      display: flex; align-items: center; padding: 10px 16px;
      border-bottom: 1px solid var(--border-color); cursor: pointer; transition: background 0.2s;
    }
    .file-item:last-child { border-bottom: none; }
    .file-item:hover { background-color: var(--hover-bg); }
    
    .icon { margin-right: 12px; width: 20px; text-align: center; flex-shrink: 0; }
    .file-info { display: flex; flex-direction: column; flex: 1; overflow: hidden; }
    .file-name { color: var(--primary-color); font-weight: 500; }
    .file-path { font-size: 12px; color: #6a737d; margin-top: 2px; }
    .file-item:hover .file-name { text-decoration: underline; }
    .back-item { background-color: #fff9f9; font-weight: bold; }

    /* === README === */
    .readme-container { padding: 32px; border-top: 1px solid var(--border-color); }
    .readme-title {
      font-size: 12px; color: var(--text-secondary); text-transform: uppercase;
      font-weight: 600; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid #eaecef;
    }

    /* === é¢„è§ˆè§†å›¾ === */
    .preview-header-bar { display: flex; justify-content: space-between; align-items: center; width: 100%; }
    .btn {
      padding: 6px 12px; border: 1px solid var(--border-color); border-radius: 4px;
      cursor: pointer; font-size: 14px; background: #fafbfc; text-decoration: none; color: #24292e; display: inline-block;
    }
    .btn:hover { background-color: #f3f4f6; }
    .btn-primary { background-color: #2ea44f; color: white; border: 1px solid rgba(27,31,35,.15); }
    .btn-primary:hover { background-color: #2c974b; }
    
    .preview-body { padding: 20px; flex: 1; display: flex; flex-direction: column; min-height: 400px; }
    .preview-image { max-width: 100%; display: block; margin: 0 auto; }
    .preview-code { background: #f6f8fa; padding: 15px; border-radius: 4px; overflow-x: auto; }
    .pdf-frame { width: 100%; height: 80vh; border: 1px solid var(--border-color); border-radius: 4px; }

    /* === æ–°å¢ï¼šé¡µè„š === */
    .page-footer {
      margin-top: auto;
      padding: 20px;
      color: #6a737d;
      font-size: 12px;
      text-align: center;
    }

    .hidden { display: none !important; }

    /* ç§»åŠ¨ç«¯é€‚é…å°è°ƒæ•´ */
    @media (max-width: 600px) {
      .container { width: 100%; border: none; border-radius: 0; }
      .search-wrapper { width: 150px; }
    }
  </style>
</head>
<body>

<!-- å¤´éƒ¨æ ‡é¢˜ -->
<header class="page-header">
  <h1 class="page-title">ustCShame</h1>
</header>

<div class="container">
  
  <!-- è§†å›¾ 1: åˆ—è¡¨/æœç´¢ -->
  <div id="view-list">
    <div class="header">
      <div class="breadcrumb-container" id="breadcrumb">
        <span>/</span>
      </div>
      <div class="search-wrapper">
        <input type="text" id="searchInput" class="search-input" placeholder="æœç´¢æ–‡ä»¶..." autocomplete="off">
      </div>
    </div>

    <div class="file-list" id="fileList">
      <div style="padding: 20px; text-align: center; color: #666;">åŠ è½½ä¸­...</div>
    </div>

    <div id="readmeBox" class="readme-container hidden">
      <div class="readme-title">README.md</div>
      <div id="readmeFooter" class="markdown-body"></div>
    </div>
  </div>

  <!-- è§†å›¾ 2: é¢„è§ˆ -->
  <div id="view-preview" class="hidden">
    <div class="header">
      <div class="preview-header-bar">
        <button class="btn" onclick="exitPreview()">â¬… è¿”å›</button>
        <span id="previewTitle" style="font-weight: bold; margin: 0 10px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">File</span>
        <a id="downloadBtn" class="btn btn-primary" href="#" target="_blank">â¬‡ ä¸‹è½½</a>
      </div>
    </div>
    <div id="previewContent" class="preview-body markdown-body"></div>
  </div>

</div>

<!-- é¡µè„šç‰ˆæƒ -->
<footer class="page-footer">
  <p>&copy; <script>document.write(new Date().getFullYear());</script> ustCShame. All rights reserved.</p>
  <p>ä»…ä¾›å­¦ä¹ äº¤æµä½¿ç”¨ï¼Œè¯·å‹¿ç”¨äºå•†ä¸šç”¨é€”</p>
</footer>

<script>
  let rootTree = [];
  let pathStack = []; // ä¾ç„¶å­˜å‚¨å¯¹è±¡æ ˆï¼Œä½†ä¸»è¦ä¾èµ– URL Hash æ¥åŒæ­¥
  let isSearching = false;

  async function init() {
    try {
      const res = await fetch('tree.json');
      rootTree = await res.json();
      
      // 1. åˆå§‹åŒ–æ—¶ï¼Œæ ¹æ®å½“å‰ Hash æ¢å¤è·¯å¾„
      syncStateFromHash();

      // 2. ç›‘å¬æµè§ˆå™¨å‰è¿›/åé€€/æ‰‹åŠ¨ä¿®æ”¹ URL
      window.addEventListener('hashchange', () => {
        syncStateFromHash();
      });

      // 3. æœç´¢æ¡†ç›‘å¬
      document.getElementById('searchInput').addEventListener('input', (e) => {
        const keyword = e.target.value.trim();
        if (keyword) {
          isSearching = true;
          performSearch(keyword);
        } else {
          isSearching = false;
          // é€€å‡ºæœç´¢æ—¶ï¼Œé‡æ–°æ¸²æŸ“å½“å‰ pathStack
          renderList(); 
        }
      });

    } catch (e) {
      document.getElementById('fileList').innerHTML = `<div style="padding:20px; color:red;">æ— æ³•åŠ è½½ tree.json</div>`;
      console.error(e);
    }
  }

  // === æ ¸å¿ƒé€»è¾‘ï¼šHash è·¯ç”±åŒæ­¥ ===
  
  // æ ¹æ® URL Hash é‡å»º pathStack å¹¶æ¸²æŸ“
  function syncStateFromHash() {
    // è§£ç  hash (å»æ‰ #)
    const hash = decodeURIComponent(window.location.hash.slice(1)); 
    
    // å¦‚æœ hash ä¸ºç©ºï¼Œè¯´æ˜æ˜¯æ ¹ç›®å½•
    if (!hash) {
      pathStack = [];
      isSearching = false;
      document.getElementById('searchInput').value = ''; // æ¸…ç©ºæœç´¢
      exitPreview(false); // ç¡®ä¿é€€å‡ºé¢„è§ˆæ¨¡å¼
      renderList();
      return;
    }

    // è§£æè·¯å¾„ 'A/B/C' -> ['A', 'B', 'C']
    const parts = hash.split('/').filter(p => p);
    
    // å°è¯•åœ¨ tree ä¸­å¯»æ‰¾è¿™æ¡è·¯å¾„
    const newStack = [];
    let currentNodes = rootTree;
    let valid = true;

    for (const part of parts) {
      const foundNode = currentNodes.find(n => n.name === part && n.type === 'dir');
      if (foundNode) {
        newStack.push(foundNode);
        currentNodes = foundNode.children || [];
      } else {
        valid = false;
        break;
      }
    }

    if (valid) {
      pathStack = newStack;
      isSearching = false; // è·¯å¾„è·³è½¬ä¼šé€€å‡ºæœç´¢æ¨¡å¼
      document.getElementById('searchInput').value = '';
      exitPreview(false); // é€€å‡ºé¢„è§ˆ
      renderList();
    } else {
      // è·¯å¾„ä¸å­˜åœ¨ï¼Œå›é€€åˆ°æ ¹ç›®å½•å¹¶æ¸…é™¤ hash
      console.warn('Hash path not found:', hash);
      window.location.hash = '';
      // (hash change ä¼šå†æ¬¡è§¦å‘ syncStateFromHash -> æ¸²æŸ“æ ¹ç›®å½•)
    }
  }

  // === å¯¼èˆªæ“ä½œ ===

  // è¿›å…¥æ–‡ä»¶å¤¹ -> åªä¿®æ”¹ Hashï¼Œè§¦å‘ hashchange äº‹ä»¶æ¥æ¸²æŸ“
  function enterFolder(node) {
    // ä¸´æ—¶æ„å»ºä¸€ä¸‹æ–°è·¯å¾„å­—ç¬¦ä¸²ï¼Œç”¨äºè®¾ç½® hash
    const currentPathNames = pathStack.map(n => n.name);
    currentPathNames.push(node.name);
    window.location.hash = currentPathNames.join('/');
  }

  // è¿”å›ä¸Šä¸€çº§ -> ä¿®æ”¹ Hash
  function goBackFolder() {
    // æ–¹æ³• 1: ä½¿ç”¨ history.back() ä½“éªŒæœ€å¥½
    window.history.back();
    
    // æ–¹æ³• 2 (å¤‡é€‰): æ‰‹åŠ¨åˆ‡ hash
    // const newPath = pathStack.slice(0, -1).map(n => n.name).join('/');
    // window.location.hash = newPath;
  }

  // é¢åŒ…å±‘è·³è½¬
  function jumpToBreadcrumb(index) {
    // index æ˜¯ç›®æ ‡å±‚çº§çš„ç´¢å¼•ã€‚0 è¡¨ç¤ºç¬¬ä¸€å±‚æ–‡ä»¶å¤¹
    // æ ¹ç›®å½•æ˜¯ç‰¹æ®Šå¤„ç†
    if (index === -1) {
      window.location.hash = '';
    } else {
      const newPath = pathStack.slice(0, index + 1).map(n => n.name).join('/');
      window.location.hash = newPath;
    }
  }

  // === æ¸²æŸ“é€»è¾‘ ===

  function renderList() {
    document.getElementById('view-list').classList.remove('hidden');
    document.getElementById('view-preview').classList.add('hidden');
    
    if (!isSearching) {
      document.getElementById('breadcrumb').style.visibility = 'visible';
      document.getElementById('readmeBox').classList.add('hidden');
    }

    const container = document.getElementById('fileList');
    container.innerHTML = '';

    const nodes = (pathStack.length === 0) ? rootTree : (pathStack[pathStack.length - 1].children || []);
    // è·å–å½“å‰è·¯å¾„å‰ç¼€
    const currentBasePath = pathStack.map(n => n.name).join('/') + (pathStack.length ? '/' : '');

    renderBreadcrumb();

    // è¿”å›æŒ‰é’®
    if (pathStack.length > 0) {
      const backDiv = document.createElement('div');
      backDiv.className = 'file-item back-item';
      backDiv.innerHTML = `<span class="icon">ğŸ”™</span><div class="file-info"><span class="file-name">.. (è¿”å›ä¸Šä¸€çº§)</span></div>`;
      backDiv.onclick = goBackFolder;
      container.appendChild(backDiv);
    }

    // æ’åº
    const sortedNodes = [...nodes].sort((a, b) => {
      if (a.type === b.type) return a.name.localeCompare(b.name);
      return a.type === 'dir' ? -1 : 1;
    });

    if (sortedNodes.length === 0) {
      container.innerHTML += `<div style="padding:20px; text-align:center; color:#999;">ç©ºç›®å½•</div>`;
    }

    sortedNodes.forEach(node => {
      const el = document.createElement('div');
      el.className = 'file-item';
      const icon = node.type === 'dir' ? 'ğŸ“' : 'ğŸ“„';
      
      el.innerHTML = `<span class="icon">${icon}</span><div class="file-info"><span class="file-name">${node.name}</span></div>`;

      if (node.type === 'dir') {
        el.onclick = () => enterFolder(node);
      } else {
        el.onclick = () => enterPreview(node, currentBasePath + node.name);
      }
      container.appendChild(el);
    });

    handleReadmeInList(nodes, currentBasePath);
  }

  function renderBreadcrumb() {
    const header = document.getElementById('breadcrumb');
    header.innerHTML = '';
    
    const rootSpan = document.createElement('span');
    rootSpan.textContent = 'ğŸ  Root';
    rootSpan.className = pathStack.length === 0 ? '' : 'breadcrumb-item';
    if(pathStack.length > 0) rootSpan.onclick = () => jumpToBreadcrumb(-1);
    header.appendChild(rootSpan);

    pathStack.forEach((node, index) => {
      const sep = document.createElement('span');
      sep.className = 'breadcrumb-separator';
      sep.textContent = '/';
      header.appendChild(sep);

      const span = document.createElement('span');
      span.textContent = node.name;
      if (index < pathStack.length - 1) {
        span.className = 'breadcrumb-item';
        span.onclick = () => jumpToBreadcrumb(index);
      }
      header.appendChild(span);
    });
  }

  async function handleReadmeInList(nodes, basePath) {
    const readmeNode = nodes.find(n => n.name.toLowerCase() === 'readme.md');
    const readmeBox = document.getElementById('readmeBox');
    const contentDiv = document.getElementById('readmeFooter');
    
    if (readmeNode) {
      const path = basePath + readmeNode.name;
      try {
        const text = await fetch(path).then(r => r.text());
        contentDiv.innerHTML = marked.parse(text);
        readmeBox.classList.remove('hidden');
      } catch (e) {
        readmeBox.classList.add('hidden');
      }
    } else {
      readmeBox.classList.add('hidden');
      contentDiv.innerHTML = '';
    }
  }

  // === æœç´¢é€»è¾‘ ===
  function performSearch(keyword) {
    const container = document.getElementById('fileList');
    const lowerKey = keyword.toLowerCase();
    const results = [];

    document.getElementById('breadcrumb').style.visibility = 'hidden';
    document.getElementById('readmeBox').classList.add('hidden');

    function traverse(nodes, parentPath, parents) {
      nodes.forEach(node => {
        const fullPath = parentPath + node.name;
        if (node.name.toLowerCase().includes(lowerKey)) {
          results.push({ node, path: fullPath, parents: [...parents] });
        }
        if (node.type === 'dir' && node.children) {
          traverse(node.children, fullPath + '/', [...parents, node]);
        }
      });
    }

    traverse(rootTree, '', []);

    container.innerHTML = '';
    if (results.length === 0) {
      container.innerHTML = `<div style="padding:20px; text-align:center; color:#999;">æ— æœç´¢ç»“æœ</div>`;
      return;
    }

    results.forEach(res => {
      const el = document.createElement('div');
      el.className = 'file-item';
      const icon = res.node.type === 'dir' ? 'ğŸ“' : 'ğŸ“„';
      el.innerHTML = `
        <span class="icon">${icon}</span>
        <div class="file-info">
          <span class="file-name">${res.node.name}</span>
          <span class="file-path">${res.path}</span>
        </div>`;

      if (res.node.type === 'dir') {
        el.onclick = () => {
          // ç‚¹å‡»æœç´¢ç»“æœçš„æ–‡ä»¶å¤¹ -> æ”¹å˜ hash -> è§¦å‘è·³è½¬
          const pathNames = [...res.parents, res.node].map(n => n.name);
          window.location.hash = pathNames.join('/');
        };
      } else {
        el.onclick = () => enterPreview(res.node, res.path);
      }
      container.appendChild(el);
    });
  }

  // === é¢„è§ˆé€»è¾‘ ===
  async function enterPreview(node, fullPath) {
    document.getElementById('view-list').classList.add('hidden');
    document.getElementById('view-preview').classList.remove('hidden');

    document.getElementById('previewTitle').textContent = node.name;
    document.getElementById('downloadBtn').href = fullPath;

    const container = document.getElementById('previewContent');
    container.innerHTML = '<div style="text-align:center; padding: 20px;">æ­£åœ¨åŠ è½½é¢„è§ˆ...</div>';

    const ext = node.name.split('.').pop().toLowerCase();
    
    if (['png', 'jpg', 'jpeg', 'gif', 'svg', 'webp'].includes(ext)) {
      container.innerHTML = `<img src="${fullPath}" class="preview-image">`;
    } else if (['mp4', 'webm'].includes(ext)) {
      container.innerHTML = `<div style="text-align:center"><video controls style="max-width:100%"><source src="${fullPath}"></video></div>`;
    } else if (ext === 'pdf') {
      container.innerHTML = `<iframe src="${fullPath}" class="pdf-frame" frameborder="0"><p>è¯·ä¸‹è½½æŸ¥çœ‹ã€‚</p></iframe>`;
    } else if (['md', 'markdown'].includes(ext)) {
      try {
        const text = await fetch(fullPath).then(r => r.text());
        container.innerHTML = marked.parse(text);
      } catch (e) { container.innerHTML = 'åŠ è½½å¤±è´¥'; }
    } else if (['txt', 'js', 'json', 'css', 'html', 'py', 'java', 'c', 'cpp', 'h', 'go', 'rs'].includes(ext)) {
      try {
        const text = await fetch(fullPath).then(r => r.text());
        const safeText = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        container.innerHTML = `<pre class="preview-code"><code>${safeText}</code></pre>`;
      } catch (e) { container.innerHTML = 'åŠ è½½å¤±è´¥'; }
    } else {
      container.innerHTML = `<div style="text-align:center; margin-top:50px; color:#666;"><p>æ­¤æ–‡ä»¶ä¸æ”¯æŒåœ¨çº¿é¢„è§ˆï¼Œè¯·ä¸‹è½½ã€‚</p></div>`;
    }
  }

  function exitPreview(render = true) {
    document.getElementById('view-preview').classList.add('hidden');
    document.getElementById('previewContent').innerHTML = '';
    // å¦‚æœæ˜¯æœç´¢å¯¼è‡´çš„é€€å‡ºï¼Œå¯èƒ½ä¸éœ€è¦ç«‹å³ renderï¼Œç”± hash change å¤„ç†
    if (render) {
      document.getElementById('view-list').classList.remove('hidden');
    }
  }

  init();
</script>

</body>
</html>