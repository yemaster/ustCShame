<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ustCShame</title>
  
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css/github-markdown.min.css">
  
  <style>
    /* =========================================
       CSS å˜é‡ (æ·±è‰²/æµ…è‰²æ¨¡å¼)
       ========================================= */
    :root {
      --primary-color: #0366d6;
      --bg-color: #f6f8fa;
      --card-bg: #ffffff;
      --text-primary: #24292e;
      --text-secondary: #586069;
      --border-color: #e1e4e8;
      --header-bg: #fcfcfc;
      --hover-bg: #f6f8fa;
      --item-hover-bg: #f1f8ff;
      --btn-bg: #fafbfc;
      --btn-border: #1b1f2326;
      --btn-hover-bg: #f3f4f6;
      --code-bg: #f6f8fa;
      --back-item-bg: #fff9f9;
      --separator-color: #999;
      --shadow-color: rgba(0,0,0,0.05);
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --primary-color: #58a6ff;
        --bg-color: #0d1117;
        --card-bg: #161b22;
        --text-primary: #c9d1d9;
        --text-secondary: #8b949e;
        --border-color: #30363d;
        --header-bg: #161b22;
        --hover-bg: #161b22;
        --item-hover-bg: #1f2428;
        --btn-bg: #21262d;
        --btn-border: #363b42;
        --btn-hover-bg: #30363d;
        --code-bg: #0d1117;
        --back-item-bg: #1c1e23;
        --separator-color: #484f58;
        --shadow-color: rgba(0,0,0,0.3);
      }
      .markdown-body {
        color: var(--text-primary) !important;
        background-color: transparent !important;
      }
      .markdown-body a { color: var(--primary-color) !important; }
      .markdown-body pre, .markdown-body code { background-color: var(--code-bg) !important; }
      iframe { background-color: #fff; }
    }

    /* =========================================
       å¸ƒå±€æ ·å¼
       ========================================= */
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
      background-color: var(--bg-color);
      color: var(--text-primary);
      margin: 0; padding: 0;
      display: flex; flex-direction: column; align-items: center;
      min-height: 100vh;
      transition: background-color 0.3s, color 0.3s;
    }

    .page-header { margin-top: 40px; margin-bottom: 20px; text-align: center; }
    .page-title { font-size: 32px; font-weight: 300; color: var(--text-primary); margin: 0; }

    .container {
      width: 90%; max-width: 980px;
      background: var(--card-bg);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      box-shadow: 0 1px 3px var(--shadow-color);
      display: flex; flex-direction: column;
      min-height: 500px; margin-bottom: 20px;
    }

    /* é¡¶éƒ¨å·¥å…·æ  */
    .header {
      padding: 12px 16px;
      background: var(--header-bg);
      border-bottom: 1px solid var(--border-color);
      display: flex; align-items: center; justify-content: space-between;
      gap: 15px;
      border-top-left-radius: 6px; border-top-right-radius: 6px;
    }

    .breadcrumb-container {
      font-size: 14px; font-weight: 600; color: var(--text-secondary);
      flex: 1; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;
    }
    .breadcrumb-item { cursor: pointer; color: var(--primary-color); }
    .breadcrumb-item:hover { text-decoration: underline; }
    .breadcrumb-separator { margin: 0 5px; color: var(--separator-color); }

    .search-wrapper { position: relative; width: 250px; }
    .search-input {
      width: 100%; padding: 6px 12px;
      border: 1px solid var(--border-color);
      background-color: var(--bg-color);
      color: var(--text-primary);
      border-radius: 6px; font-size: 14px; outline: none; box-sizing: border-box;
    }
    .search-input:focus { border-color: var(--primary-color); box-shadow: 0 0 0 3px rgba(3, 102, 214, 0.3); }

    /* æ–‡ä»¶åˆ—è¡¨ */
    .file-list { list-style: none; margin: 0; padding: 0; }
    .file-item {
      display: flex; align-items: center; padding: 10px 16px;
      border-bottom: 1px solid var(--border-color); cursor: pointer;
      transition: background 0.1s;
    }
    .file-item:last-child { border-bottom: none; }
    .file-item:hover { background-color: var(--item-hover-bg); }
    
    .icon { margin-right: 12px; width: 20px; text-align: center; flex-shrink: 0; }
    .file-info { display: flex; flex-direction: column; flex: 1; overflow: hidden; }
    .file-name { color: var(--primary-color); font-weight: 500; }
    .file-path { font-size: 12px; color: var(--text-secondary); margin-top: 2px; }
    .file-item:hover .file-name { text-decoration: underline; }
    .back-item { background-color: var(--back-item-bg); }

    /* README */
    .readme-container { padding: 32px; border-top: 1px solid var(--border-color); }
    .readme-title {
      font-size: 12px; color: var(--text-secondary); text-transform: uppercase;
      font-weight: 600; margin-bottom: 10px; padding-bottom: 10px;
      border-bottom: 1px solid var(--border-color);
    }

    /* é¢„è§ˆè§†å›¾ */
    .preview-header-bar { display: flex; justify-content: space-between; align-items: center; width: 100%; }
    
    .btn {
      padding: 6px 12px;
      border: 1px solid var(--border-color);
      background: var(--btn-bg);
      color: var(--text-primary);
      border-radius: 4px; cursor: pointer; font-size: 14px;
      text-decoration: none; display: inline-block; transition: 0.2s;
    }
    .btn:hover { background-color: var(--btn-hover-bg); border-color: var(--text-secondary); }
    
    .btn-primary { background-color: #2ea44f; color: white; border: 1px solid rgba(27,31,35,.15); }
    .btn-primary:hover { background-color: #2c974b; border-color: rgba(27,31,35,.15); }
    
    .preview-body { padding: 20px; flex: 1; display: flex; flex-direction: column; min-height: 400px; }
    .preview-image { max-width: 100%; display: block; margin: 0 auto; }
    .preview-code {
      background: var(--code-bg); color: var(--text-primary);
      padding: 15px; border-radius: 4px; overflow-x: auto;
      border: 1px solid var(--border-color);
    }
    .pdf-frame { width: 100%; height: 80vh; border: 1px solid var(--border-color); border-radius: 4px; }

    .page-footer { margin-top: auto; padding: 20px; color: var(--text-secondary); font-size: 12px; text-align: center; }
    .hidden { display: none !important; }

    @media (max-width: 600px) {
      .container { width: 100%; border-left: none; border-right: none; border-radius: 0; }
      .search-wrapper { width: 140px; }
    }
  </style>
</head>
<body>

<header class="page-header">
  <h1 class="page-title">ustCShame</h1>
</header>

<div class="container">
  
  <!-- åˆ—è¡¨è§†å›¾ -->
  <div id="view-list">
    <div class="header">
      <div class="breadcrumb-container" id="breadcrumb">
        <span>/</span>
      </div>
      <div class="search-wrapper">
        <input type="text" id="searchInput" class="search-input" placeholder="æœç´¢..." autocomplete="off">
      </div>
    </div>

    <div class="file-list" id="fileList">
      <div style="padding: 20px; text-align: center; color: var(--text-secondary);">åŠ è½½ä¸­...</div>
    </div>

    <div id="readmeBox" class="readme-container hidden">
      <div class="readme-title">README.md</div>
      <div id="readmeFooter" class="markdown-body"></div>
    </div>
  </div>

  <!-- é¢„è§ˆè§†å›¾ -->
  <div id="view-preview" class="hidden">
    <div class="header">
      <div class="preview-header-bar">
        <button class="btn" onclick="closePreview()">â¬… è¿”å›</button>
        <span id="previewTitle" style="font-weight: bold; margin: 0 10px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">File</span>
        <a id="downloadBtn" class="btn btn-primary" href="#" target="_blank">â¬‡ ä¸‹è½½</a>
      </div>
    </div>
    <div id="previewContent" class="preview-body markdown-body"></div>
  </div>

</div>

<footer class="page-footer">
  <p>&copy; <script>document.write(new Date().getFullYear());</script> ustCShame. All rights reserved.</p>
  <p>ä»…ä¾›å­¦ä¹ äº¤æµä½¿ç”¨ï¼Œè¯·å‹¿ç”¨äºå•†ä¸šç”¨é€”</p>
</footer>

<script>
  let rootTree = [];
  let pathStack = []; 

  async function init() {
    try {
      const res = await fetch('tree.json');
      rootTree = await res.json();
      
      // 1. ç›‘å¬ Hash å˜åŒ–
      window.addEventListener('hashchange', syncStateFromHash);

      // 2. æœç´¢è¾“å…¥
      document.getElementById('searchInput').addEventListener('input', (e) => {
        const keyword = e.target.value.trim();
        if (keyword) {
          // æ›´æ–° Hash ä¸º #search=xxx
          window.history.replaceState(null, null, '#search=' + encodeURIComponent(keyword));
          syncStateFromHash(); 
        } else {
          // æ¸…ç©ºæœç´¢æ—¶ï¼Œå›åˆ°æ ¹ç›®å½•
          window.location.hash = '';
        }
      });

      // 3. åˆå§‹åŒ–
      syncStateFromHash();

    } catch (e) {
      document.getElementById('fileList').innerHTML = `<div style="padding:20px; color:red;">æ— æ³•åŠ è½½ tree.json</div>`;
      console.error(e);
    }
  }

  // === æ ¸å¿ƒè·¯ç”±è§£æå™¨ ===
  function syncStateFromHash() {
    const rawHash = window.location.hash.slice(1); // å»æ‰ #
    
    // æƒ…å†µ 1: ç©º Hash -> æ ¹ç›®å½•
    if (!rawHash) {
      resetToRoot();
      return;
    }

    // è§£æå‰ç¼€ type å’Œå€¼ value
    // æ ¼å¼: #type=value
    const firstEquals = rawHash.indexOf('=');
    let type = '';
    let value = '';

    if (firstEquals === -1) {
      // å…¼å®¹æ—§ç‰ˆé€»è¾‘æˆ–é”™è¯¯æ ¼å¼ï¼Œå½“ä½œç›®å½•å¤„ç†ï¼Œå¦‚æœå‡ºé”™ä¼šå›é€€
      type = 'dir';
      value = decodeURIComponent(rawHash);
    } else {
      type = rawHash.substring(0, firstEquals);
      value = decodeURIComponent(rawHash.substring(firstEquals + 1));
    }

    // æ¸…ç©ºæœç´¢æ¡†ï¼ˆé™¤éæ˜¯ search æ¨¡å¼ï¼‰
    if (type !== 'search') {
      document.getElementById('searchInput').value = '';
    }

    switch (type) {
      case 'search':
        handleSearchRoute(value);
        break;
      case 'dir':
        handleDirRoute(value);
        break;
      case 'file':
        handleFileRoute(value);
        break;
      default:
        console.warn('Unknown hash type:', type);
        resetToRoot();
    }
  }

  // === è·¯ç”±å¤„ç†å™¨ ===

  function resetToRoot() {
    pathStack = [];
    document.getElementById('searchInput').value = '';
    exitPreviewUI();
    renderListUI();
  }

  function handleSearchRoute(keyword) {
    if (!keyword) {
      window.location.hash = '';
      return;
    }
    // æ¢å¤è¾“å…¥æ¡†æ–‡å­—
    const input = document.getElementById('searchInput');
    if (input.value !== keyword) input.value = keyword;
    
    performSearchUI(keyword);
  }

  function handleDirRoute(pathStr) {
    // éªŒè¯å¹¶æ„å»º pathStack
    const { stack, valid } = resolvePath(pathStr);
    
    if (valid) {
      pathStack = stack;
      exitPreviewUI();
      renderListUI();
    } else {
      console.warn('Invalid dir path:', pathStr);
      window.location.hash = ''; // å›é€€åˆ°æ ¹ç›®å½•
    }
  }

  function handleFileRoute(pathStr) {
    // æ–‡ä»¶è·¯å¾„é€šå¸¸æ˜¯ "folder/sub/file.txt"
    // æˆ‘ä»¬éœ€è¦æ‰¾åˆ°å®ƒæ‰€åœ¨çš„æ–‡ä»¶å¤¹ "folder/sub" ä»¥åŠæ–‡ä»¶èŠ‚ç‚¹ "file.txt"
    
    // 1. å°è¯•ç›´æ¥è§£æ
    // ç”±äº split('/') å¯èƒ½ä¼šæŠŠæ–‡ä»¶ååˆ‡å¼€ï¼Œæˆ‘ä»¬åˆ©ç”¨ resolvePath æ‰¾çˆ¶çº§
    const parts = pathStr.split('/').filter(p => p);
    if (parts.length === 0) { resetToRoot(); return; }

    const fileName = parts.pop(); // æœ€åä¸€ä¸ªæ˜¯æ–‡ä»¶å
    const dirPath = parts.join('/'); // å‰©ä¸‹çš„æ˜¯ç›®å½•è·¯å¾„

    // è§£æç›®å½•
    const { stack, valid } = resolvePath(dirPath);
    
    if (!valid) {
      console.warn('Parent dir not found for file:', pathStr);
      window.location.hash = '';
      return;
    }

    // åœ¨ç›®æ ‡ç›®å½•ä¸­å¯»æ‰¾æ–‡ä»¶èŠ‚ç‚¹
    const parentNode = stack.length === 0 ? { children: rootTree } : stack[stack.length - 1];
    const fileNode = parentNode.children.find(n => n.name === fileName && n.type !== 'dir');

    if (fileNode) {
      pathStack = stack; // è®¾ç½®ä¸Šä¸‹æ–‡ä¸ºçˆ¶çº§æ–‡ä»¶å¤¹
      renderListUI(); // æ¸²æŸ“èƒŒæ™¯åˆ—è¡¨
      openPreviewUI(fileNode, pathStr); // æ‰“å¼€é¢„è§ˆ
    } else {
      console.warn('File node not found:', fileName);
      // å¦‚æœæ–‡ä»¶æ‰¾ä¸åˆ°ï¼Œé€€è€Œæ±‚å…¶æ¬¡å±•ç¤ºæ–‡ä»¶å¤¹
      window.location.hash = '#dir=' + dirPath;
    }
  }

  // === è¾…åŠ©å·¥å…·ï¼šè·¯å¾„è§£æ ===
  // è¾“å…¥ "A/B" -> è¿”å› { stack: [NodeA, NodeB], valid: true }
  // è¾“å…¥ "" -> è¿”å› { stack: [], valid: true } (æ ¹ç›®å½•)
  function resolvePath(pathStr) {
    if (!pathStr) return { stack: [], valid: true };
    
    const parts = pathStr.split('/').filter(p => p);
    const stack = [];
    let currentNodes = rootTree;
    let valid = true;

    for (const part of parts) {
      const found = currentNodes.find(n => n.name === part && n.type === 'dir');
      if (found) {
        stack.push(found);
        currentNodes = found.children || [];
      } else {
        valid = false;
        break;
      }
    }
    return { stack, valid };
  }

  // === å¯¼èˆªåŠ¨ä½œ (æ›´æ–° Hash) ===

  function enterFolder(node) {
    const currentPathNames = pathStack.map(n => n.name);
    currentPathNames.push(node.name);
    window.location.hash = '#dir=' + currentPathNames.join('/');
  }

  function clickFile(node) {
    const currentPathNames = pathStack.map(n => n.name);
    currentPathNames.push(node.name);
    window.location.hash = '#file=' + currentPathNames.join('/');
  }

  function goBackFolder() {
    // ä» dir æ¨¡å¼è¿”å›ä¸Šä¸€çº§
    if (pathStack.length > 0) {
      const newStack = pathStack.slice(0, -1);
      const pathStr = newStack.map(n => n.name).join('/');
      window.location.hash = pathStr ? ('#dir=' + pathStr) : '';
    }
  }

  function quitSearch() {
    // é€€å‡ºæœç´¢ï¼Œæ¸…ç©ºå¹¶è¿”å›æ ¹ç›®å½•
    document.getElementById('searchInput').value = '';
    window.location.hash = '';
  }

  function closePreview() {
    // å…³é—­é¢„è§ˆ -> åˆ‡æ¢å›å½“å‰ pathStack çš„ dir è§†å›¾
    const pathStr = pathStack.map(n => n.name).join('/');
    window.location.hash = pathStr ? ('#dir=' + pathStr) : '';
  }

  function jumpToBreadcrumb(index) {
    if (index === -1) {
      window.location.hash = '';
    } else {
      const newPath = pathStack.slice(0, index + 1).map(n => n.name).join('/');
      window.location.hash = '#dir=' + newPath;
    }
  }

  function clickSearchResultDir(parents, node) {
    const pathNames = [...parents, node].map(n => n.name);
    window.location.hash = '#dir=' + pathNames.join('/');
  }

  function clickSearchResultFile(fullPath) {
    window.location.hash = '#file=' + fullPath;
  }

  // === UI æ¸²æŸ“ ===

  function renderListUI() {
    document.getElementById('view-list').classList.remove('hidden');
    document.getElementById('view-preview').classList.add('hidden');
    document.getElementById('breadcrumb').style.visibility = 'visible';
    
    const container = document.getElementById('fileList');
    container.innerHTML = '';
    
    const nodes = (pathStack.length === 0) ? rootTree : (pathStack[pathStack.length - 1].children || []);
    const currentBasePath = pathStack.map(n => n.name).join('/') + (pathStack.length ? '/' : '');

    renderBreadcrumbUI();

    if (pathStack.length > 0) {
      const backDiv = document.createElement('div');
      backDiv.className = 'file-item back-item';
      backDiv.innerHTML = `<span class="icon">ğŸ”™</span><div class="file-info"><span class="file-name">.. (è¿”å›ä¸Šä¸€çº§)</span></div>`;
      backDiv.onclick = goBackFolder;
      container.appendChild(backDiv);
    }

    const sortedNodes = [...nodes].sort((a, b) => {
      if (a.type === b.type) return a.name.localeCompare(b.name);
      return a.type === 'dir' ? -1 : 1;
    });

    if (sortedNodes.length === 0) {
      container.innerHTML += `<div style="padding:20px; text-align:center; color:var(--text-secondary);">ç©ºç›®å½•</div>`;
    }

    sortedNodes.forEach(node => {
      const el = document.createElement('div');
      el.className = 'file-item';
      const icon = node.type === 'dir' ? 'ğŸ“' : 'ğŸ“„';
      el.innerHTML = `<span class="icon">${icon}</span><div class="file-info"><span class="file-name">${node.name}</span></div>`;

      if (node.type === 'dir') {
        el.onclick = () => enterFolder(node);
      } else {
        el.onclick = () => clickFile(node);
      }
      container.appendChild(el);
    });

    handleReadmeInList(nodes, currentBasePath);
  }

  function performSearchUI(keyword) {
    document.getElementById('view-list').classList.remove('hidden');
    document.getElementById('view-preview').classList.add('hidden');
    document.getElementById('breadcrumb').style.visibility = 'hidden';
    document.getElementById('readmeBox').classList.add('hidden');

    const container = document.getElementById('fileList');
    const lowerKey = keyword.toLowerCase();
    const results = [];

    function traverse(nodes, parentPath, parents) {
      nodes.forEach(node => {
        const fullPath = parentPath + node.name;
        if (node.name.toLowerCase().includes(lowerKey)) {
          results.push({ node, path: fullPath, parents: [...parents] });
        }
        if (node.type === 'dir' && node.children) {
          traverse(node.children, fullPath + '/', [...parents, node]);
        }
      });
    }
    traverse(rootTree, '', []);

    container.innerHTML = '';
    
    // === æ–°å¢ï¼šé€€å‡ºæœç´¢æŒ‰é’® ===
    const exitDiv = document.createElement('div');
    exitDiv.className = 'file-item back-item';
    exitDiv.innerHTML = `<span class="icon">ğŸ”™</span><div class="file-info"><span class="file-name">é€€å‡ºæœç´¢ / æ¸…ç©ºæ¡ä»¶</span></div>`;
    exitDiv.onclick = quitSearch;
    container.appendChild(exitDiv);

    if (results.length === 0) {
      container.innerHTML += `<div style="padding:20px; text-align:center; color:var(--text-secondary);">æ— æœç´¢ç»“æœ</div>`;
      return;
    }

    results.forEach(res => {
      const el = document.createElement('div');
      el.className = 'file-item';
      const icon = res.node.type === 'dir' ? 'ğŸ“' : 'ğŸ“„';
      el.innerHTML = `
        <span class="icon">${icon}</span>
        <div class="file-info">
          <span class="file-name">${res.node.name}</span>
          <span class="file-path">${res.path}</span>
        </div>`;

      if (res.node.type === 'dir') {
        el.onclick = () => clickSearchResultDir(res.parents, res.node);
      } else {
        el.onclick = () => clickSearchResultFile(res.path);
      }
      container.appendChild(el);
    });
  }

  async function openPreviewUI(node, fullPath) {
    document.getElementById('view-list').classList.add('hidden');
    document.getElementById('view-preview').classList.remove('hidden');
    document.getElementById('previewTitle').textContent = node.name;
    
    const btn = document.getElementById('downloadBtn');
    btn.href = fullPath;
    btn.download = node.name;

    const container = document.getElementById('previewContent');
    container.innerHTML = '<div style="text-align:center; padding: 20px;">æ­£åœ¨åŠ è½½é¢„è§ˆ...</div>';
    
    const ext = node.name.split('.').pop().toLowerCase();
    
    if (['png', 'jpg', 'jpeg', 'gif', 'svg', 'webp'].includes(ext)) {
      container.innerHTML = `<img src="${fullPath}" class="preview-image">`;
    } else if (['mp4', 'webm'].includes(ext)) {
      container.innerHTML = `<div style="text-align:center"><video controls style="max-width:100%"><source src="${fullPath}"></video></div>`;
    } else if (ext === 'pdf') {
      container.innerHTML = `<iframe src="${fullPath}" class="pdf-frame" frameborder="0"><p>è¯·ä¸‹è½½æŸ¥çœ‹ã€‚</p></iframe>`;
    } else if (['md', 'markdown'].includes(ext)) {
      try {
        const text = await fetch(fullPath).then(r => r.text());
        container.innerHTML = marked.parse(text);
      } catch (e) { container.innerHTML = 'åŠ è½½å¤±è´¥'; }
    } else if (['txt', 'js', 'json', 'css', 'html', 'py', 'java', 'c', 'cpp', 'h', 'go', 'rs'].includes(ext)) {
      try {
        const text = await fetch(fullPath).then(r => r.text());
        const safeText = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        container.innerHTML = `<pre class="preview-code"><code>${safeText}</code></pre>`;
      } catch (e) { container.innerHTML = 'åŠ è½½å¤±è´¥'; }
    } else {
      container.innerHTML = `<div style="text-align:center; margin-top:50px; color:var(--text-secondary);"><p>æ­¤æ–‡ä»¶ä¸æ”¯æŒåœ¨çº¿é¢„è§ˆï¼Œè¯·ä¸‹è½½ã€‚</p></div>`;
    }
  }

  function exitPreviewUI() {
    document.getElementById('view-preview').classList.add('hidden');
    document.getElementById('previewContent').innerHTML = '';
  }

  function renderBreadcrumbUI() {
    const header = document.getElementById('breadcrumb');
    header.innerHTML = '';
    const rootSpan = document.createElement('span');
    rootSpan.textContent = 'ğŸ  Root';
    rootSpan.className = pathStack.length === 0 ? '' : 'breadcrumb-item';
    if(pathStack.length > 0) rootSpan.onclick = () => jumpToBreadcrumb(-1);
    header.appendChild(rootSpan);

    pathStack.forEach((node, index) => {
      const sep = document.createElement('span');
      sep.className = 'breadcrumb-separator';
      sep.textContent = '/';
      header.appendChild(sep);

      const span = document.createElement('span');
      span.textContent = node.name;
      if (index < pathStack.length - 1) {
        span.className = 'breadcrumb-item';
        span.onclick = () => jumpToBreadcrumb(index);
      }
      header.appendChild(span);
    });
  }

  async function handleReadmeInList(nodes, basePath) {
    const readmeNode = nodes.find(n => n.name.toLowerCase() === 'readme.md');
    const readmeBox = document.getElementById('readmeBox');
    const contentDiv = document.getElementById('readmeFooter');
    if (readmeNode) {
      const path = basePath + readmeNode.name;
      try {
        const text = await fetch(path).then(r => r.text());
        contentDiv.innerHTML = marked.parse(text);
        readmeBox.classList.remove('hidden');
      } catch (e) {
        readmeBox.classList.add('hidden');
      }
    } else {
      readmeBox.classList.add('hidden');
      contentDiv.innerHTML = '';
    }
  }

  init();
</script>

</body>
</html>